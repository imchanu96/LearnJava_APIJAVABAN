package one;

public class InterfaceBasic1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

 /*
 * @인터페이스(Interface)란?
 * 
 * 일종의 추상클래스이다
 * 인터페이스는 추상 메서드를 갖지만 추상 클래스보다 추상화 정도가 높아서 추상클래스와 달리
 * 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.
 * 오직 추상메서드와 상수만을 멤버로 가질 수 있으며,
 * 그 외의 다른 어떠한 요소도 허용하지 않는다.
 * 
 * 
 * 
 * 추상클래스를 부분적으로만 완성된 '미완성 설계도'라고 한다면
 * 인터페이스는 구현된 것은 아무것도 없고 밑그림만 그려져 있는 '기본 설계도'라 할 수 있다.
 * 
 * 인터페이스도 추상클래스처럼 완성되지 않은 불완전한 것이기 때문에 그 자체만으로
 * 사용되기 보다는 다른 클래스를 작성하는데 도움 줄 목적으로 작성된다.
 * 
 * @인터페이스 작성
 * 클래스를 작성하는 것과 같다.
 * 다만 키워드로 class 대신 interface 를 사용한다는 것만 다르다.
 * 그리고 interface에도 클래스와 같이 접근제어자로 public를 사용할 수 있다.
 * 
 * 
 * 표현식
 * 추상적인 의미만 포함해야 하기에 구체적인 값을 넣으면 안된다.
 * 
 * interface 인터페이스명{
 * 		public static final 타입 상수명 = 값;
 * 		public abstract 메서드명(매개변수들);
 * }
 * 
 * 일반적으로 다음과 같은 제약사항이 있다.
 * - 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
 * - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
 * 단, static 메서드와 디폴트 메서드는 예외(jdk 1.8이후로는 가능해짐)
 * 
 * 
 * @왜 쓰죠?
 * 인터페이스의 장점
 * - 개발시간을 단축시킬 수 있다.
 * - 표준화가 가능하다.
 * - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
 * - 독립적인 프로그래밍이 가능하다.
 * 
 * 1. 개발 시간 단축
 * 인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능하다.
 * 메서드를 호출하는 쪽에서는 메서드의 내용에 고나계없이 선언부만 알면 되기 때문이다.
 * 그리고 동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하도록 하여,
 * 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을
 * 진행할 수 있다.
 * 
 * 2. 표준화가 가능하다.
 * 프로젝트의 기본 틀을 제공함으로써 보다 일관되고 정형화된 프로그램이 가능하다.
 * 
 * 3. 독립적인 프로그래밍이 가능하다.	-	(다형성)
 * 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에
 * 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다.
 * 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이
 * 가능하다.
 */
		
		
	}

}
